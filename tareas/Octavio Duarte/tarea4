==============================================================================================
E1.

 P(0)
a^ m*n = (a^m)^n
a^ m*0 = (a^m)^0
a^0 = (a^0)
1=1

P(k+1)
a^ m*(k+1) = (a^m)^(k+1)
a^ m*K + m = a^m* (k+1)
a^ m*K + a^m = a^mk*m
a^ m*K + a^m = a^ m*K + a^m

==============================================================================================
E2.

para n = 1

$$ \begin{aligned} \sum_{i=1}^{1} 2i-1 = 1^2 \ 2(1)-1 = 1^2 \ 1 = 1 \ \end{aligned} $$


We assume that $$ \sum_{i=1}^{n} 2i-1 = n^2 $$ is true
 
 consideramos $$ n <- n+1 $$

$$ \begin{aligned} \sum_{i=1}^{n+1} 2i-1 = (n+1)^2 \ 2(n+1)-1 + \sum_{i=1}^{n} 2i-1 = (n+1)^2 \ 2n+2-1 + \sum_{i=1}^{n} 2i-1 = (n+1)^2 \ 2n + 1 + n^2 = (n+1)^2 \ (n+1)^2 = (n+1)^2 \ \end{aligned} $$

E3. Prove that  , where a is a real
number and a _= 1.


P(1)
1 = (a^(1+1) -1)/ a-1 
1 = (a^2 -1)/ a-1

si a = 2 
1 = (2^2 -1)/ 2-1
1 != 3/1
1 != 3

==============================================================================================
E4.
nth Fibonacci number is defined as follows:

fib :: Integer -> Integer
fib 0 = 0
fib 1 = 1
fib (n+2) = fib n + fib (n+1)
The first fewnumbers in this famous sequence are 0, 1, 1, 2, 3, 5, . . .. Prove
the following:
_n
i=1
fib i = fib (n + 2) – 1


Basis 1
$$\begin{aligned} \sum_{i=1}^1 fib (i) = fib (1+2) -1 \\ fib (1) = fib (3) -1 \\ fib (1) = fib (2) + fib (1) -1 \\ fib (1) = fib (1) + fib (0) + fib (1) -1 \\ fib (1) = 1 + 0 + 1 -1 \\ fib (1) = 1 \\ 1 = 1 \\ \end{aligned}$$
Induction n hypothesis
We assume $$\sum_{i=1}^n fib (i) = fib (n+2) -1 $$ is true.
Induction n+1
$$ n <- n + 1 $$
$$\begin{aligned} \sum_{i=1}^{n+1} fib (i) = fib ((n+1)+2) -1 \\ fib (n+1) + \sum_{i=1}^n fib (i) = fib (n+3) -1 \\ fib (n+1) + fib (n+2) -1 = fib (n+3) -1 \\ fib (n+1) + fib (n+2) -1 = fib (n+2) + fib (n+1) -1 \\ QED \\ \end{aligned}$$

==============================================================================================
E5.

length (xs ++ ys) = length xs + length ys

P([])
length ([] ++ ys) = length [] + length ys        {length.1}
0 + length ys = 0 + length ys


P(x:xs)

length ((x:xs) ++ ys) = length (x:xs) + length ys
length (x: (xs ++ ys)) = 1 + length xs + length ys 	{length.1}
1 + length (xs ++ ys) = 1 +  length (xs ++ ys) 		{Hipotesis}

==============================================================================================
E6.

map f (xs ++ ys) = map f xs ++ map f ys

P([])
map f ([] ++  ys) = map f [] ++ map f ys
map f [] ++ map f ys = [] ++  map f ys
[] ++ map f ys	= [] ++  map f ys

P(x:xs)
map f ((x:xs) ++ ys)= map f (x:xs) ++ map f ys
map f (x: (xs ++ ys))= f x map f xs ++ map f ys
f x map f (xs ++ ys) = f x map f xs ++ map f ys   {map.2}
f x map f (xs ++ ys) = f x map f (xs ++ ys )	  {Hipotesis}


==============================================================================================
E7.

(map f . map g) xs = map (f.g) xs

P([])

map f (map g []) = map (f.g) []   {.1}
map f [] = map f (map g [])       {map.1}
[] = map f [] 					  {map.1}
[] = []


P(x:xs)
map f (map g (x:xs)) = map (f.g) (x:xs)
map f (g x map g xs) = map f (map g (x:xs))
f (g x) : map f (map g xs)= map f (g x : map g xs)
(f.g) x : map (f.g) xs = (f.g)x : map (f.g) xs

==============================================================================================
E8.



Explain in English what this theorem says. Using the definitions of the functions involved (sum, length and map), calculate the values of the left and right-hand sides of the equation using xs = [1, 2, 3, 4].


xs = [1,2,3,4]

sum (map (1+) [1,2,3,4])= length [1,2,3,4] + sum [1,2,3,4]
sum (1+1 : map (1+) [2,3,4]) = 1 + length [2,3,4] + 1 + sum [2,3,4]
sum (2 : 1+2 : map (1+) [3,4]) = 1 + 1 + length [3,4] + 1 + 2 + sum [3,4]
sum (2 : 3 : 1+3 : map (1+) [4]) = 1+ 1 + 1 + length [4] = 1 + 2 + 3 + sum [4]
sum (2: 3 : 4 : 1+4 : map (1+) []) = 1 + 1 + 1 + 1 + 0 + 1 + 2 + 3 + 4 + 0
sum (2:3:4:5:[]) = 14
sum ([2,3,4,5]) =14
2 + sum [3,4,5] = 14
2 + 3 + sum [4,5] = 14
2 + 3 + 4 + sum [5] = 14
2 + 3 + 4 + 5 + 0 = 14
14 = 14

==============================================================================================
E9.


sum (map (k+) []) = k*length [] + sum []
sum ([])          = k*lenght [] + sum [] {def map f []}
               0  = k*lenght [] + 0      {def sum []}
               0  = k*0 + 0              {def len []}
               0  = 0


sum (map (k+) x:xs)            = k*length x:xs + sum x:xs
sum (((k+)x): map (k+) xs )    = k*lenght x:xs + sum x:xs {def map f x:xs}
((k+)x) + sum (map (k+) xs )   = k*lenght x:xs + sum x:xs {def sum x:xs}
((k+)x) + k*length xs + sum xs = k*lenght x:xs + sum x:xs {hypothesis}
k + x + k*length xs + sum xs   = k*lenght x:xs + sum x:xs {parenthesis}
k + k*length xs + x + sum xs   = k*lenght x:xs + sum x:xs {changed order}
k * (1+lenght xs) + x + sum xs = k*lenght x:xs + sum x:xs {factorizing k}
k * (lenght x:xs) + x + sum xs = k*lenght x:xs + sum x:xs {def len x:xs}
k * (lenght x:xs) + sum x:xs   = k*lenght x:xs + sum x:xs {def sum x:xs}


==============================================================================================
E10.

map f . concat = concat (map (map f))
map f (concat xs) = concat (map (map f) xs)


P([])
map f (concat []) = concat (map (map f) [])
map f [] = concat ([])
[] = []

P(x:xs)
map f (concat (x:xs) = concat (map (map f) (x:xs))
map f (x ++ concat xs) = concat ( map f x : map (map f) xs)
map f x ++ map concat xs = map f x ++ concat ( concat map (map f) xs)
map f x ++ map concat xs = map f x ++ map concat xs

==============================================================================================
E11.

(a ++ b) ++ c = a ++ (b ++ c)

P([])
([] ++ b) ++ c = [] ++ (b ++ c)
b ++ c = b ++ c


p(a:as)
((a:as) ++ b ) ++ c = (a:as) ++ (b ++ c)
a : (as ++ b) ++ c = a : as ++ (b ++ c)
a : (as ++ b) ++ c = a : (as ++ b) ++ c

==============================================================================================
E12.

sum . map length xs = length . concat xs
sum (map length xs) = length (concat xs)

P([])
sum (map length []) = length (concat [])
sum	[] = length []
0 = 0

P(x:xs)
sum (map length (x:xs)) = length (concat (x:xs))
sum (length x : map	length xs) = length ( x + concat xs)
length x + sum map length xs = length x + length concat xs
length x + length concat xs = length x + length concat xs


==============================================================================================
E13.

P(n) = n+1 Horses
A= h1.. hn
B= h2..hn+1

P(1)
A = h1

Para el caso de cuando vale 1, no se cumple debido a que no se cuentan con los valores necesarios para realizar el conjunto C

==============================================================================================
E14.

P(n) ≡ concat xss = foldr (++) [] xss

Para que se pueda realizar la comprobacion, se requiere que la lista sea finite. Cuando se realizan comprobaciones con listas, se requiere que están sea de un valor finito, esto debido a que para que se pueda llegar a un resultado, se necesita recorrer la lista, y como no se tiene un valor para esta, nunca se llega a un resultado.

==============================================================================================
E15.

reverse . reverse = id
reverse (reverse xs) =xs

xs = [1,2,3]
reverse (reverse [1,2,3])= [1,2,3]
reverse (reverse [2,3] ++ [1]) = [1,2,3]
reverse (reverse [3] ++ [2] ++ [1]) = [1,2,3]
reverse (reverse [] ++ [3] ++ [2] ++ [1]) = [1,2,3]
reverse ([3,2,1])= [1,2,3]
reverse [2,1] ++ [3] = [1,2,3]
reverse [1] ++ [2] ++ [3]  = [1,2,3]
reverse[] ++ [1] ++ [2] ++ [3] = [1,2,3]
[1,2,3] = [1,2,3]

==============================================================================================
E16.

reverse (xs++ys) = reverse ys++reverse xs


Then decide whether this theorem happens to be true for infinite lists like [1 . .]. Try to give a good argument for your conclusion, but you don’t have to prove it.

P([])
reverse ([] ++ ys) = reverse [] ++ reverse ys
reverse [] ++ reverse ys = reverse ys
reverse ys	= reverse ys

P(x:xs)
reverse ((x:xs) ++ ys) = reverse (x:xs) ++  reverse ys
reverse (x:(xs ++ ys))= reverse xs + x ++  reverse ys
reverse (xs ++ ys) ++ x = x ++  reverse (xs ++ ys)
x ++  reverse (xs ++ ys) = x ++  reverse (xs ++ ys)


==============================================================================================
E17.
reverse (reverse []) []
reverse [] = []
[] = []

P(x:xs)
reverse (reverse (x:xs))= x:xs

reverse (reverse xs ++ x) = x:xs
reverse (reverse xs) ++  reverse x = x:xs 
x:xs = x:xs


E18.

El teorema no se cumple para las listas infinitas, debido a que el primer paso es obtener el ultimo element de la lista, y si la lista es infinita, nunca se podra obtener el ultimo element, por lo tanto no se podra seguir con los siguientes pasos.

==============================================================================================
E19.

length (concat xss) = sum (map length xss).


P([])
length (concat []) = sum (map length [])
length [] = sum []
0 = 0

P(x:xs)
length (concat xss) = sum (map length xss)
length (concat (x:xs)) = sum (map length (x:xs))
length ( x ++ concat xs) = sum (length x : map length xs)
length x ++ length concat xs = length x + sum	(map length xs)
length x ++ length concat xs = length x ++ length concat xs

==============================================================================================
E20.


or xs = True
or xs = foldr (||) False xs

P(True)
True = foldr (||) False True
True = || False True
True = True

P (x:xs)
= foldr (||) False xs
= foldr (||) False (x:xs)
= x (||) foldr (||) False xs


Caso 1 x = True
= True (||) foldr (||) False xs
= True

Caso 2 xs = True
= x (||) foldr (||) False True
= x (||) True
= True

==============================================================================================
E21.

and xs = True
and xs = foldr (&&) True xs

P(True)
True = foldr (&&) True True
True = && True True
True = True

P (x:xs)
= foldr (&&) True xs          
= foldr (&&) True (x:xs)
= x (&&) foldr (&&) True xs

caso 1 si x = True
= True && foldr True xs       {Hipotesis}
= True && True
= True

==============================================================================================
E22.

max x y = x 		if x >= y
and
max x y = y 		if y >= x


Write a function maximum that, given a non-empty sequence of values whose sizes can be compared (that is, values from a type of class Ord), delivers the largest value in the sequence.

maximum :: Ord a => [a] -> a
maximum (x:xs) = foldr (max) x xs

==============================================================================================
E23.

maximum :: [Ord] -> Ord
maximum xs = foldr (max) y ys
where xs = y:ys

prove that maximum has the following property:

(maximum xs) >= x

P([])
maximum (x:[]) = foldr (max) (x:[])
x= max x x 
x=x

maximum (y1:y:ys) = foldr max y1 y:ys
foldr max y1 y:ys = foldr max y1 y:ys
max y1 foldr max y ys = max y1 foldr max y ys


==============================================================================================
E24.

seq :: [a] -> a
seq (x:xs) = x

elemento :: [[a]] -> [a]
elemento xs = map (seq) xs

==============================================================================================
E25.

concat xs = foldr (++) [] xs

P([])
concat [] = foldr (++) [] []
[] = []

P(x:xs)
concat (x:xs) = foldr (++) [] (x:xs)
x ++  concat xs = x ++ foldr (++) [] xs
x ++ foldr (++) [] xs = x ++ foldr (++) [] xs

==============================================================================================
E26.
 
and :: [Bool] -> Bool
and	xs = foldr (&&) True xs


==============================================================================================
E27.

and ([False] ++ xs) = False.

and :: [Bool] -> Bool
and	xs = foldr (&&) True xs

and ([False] ++ xs) = False

P(True)
foldr (&&) True (False:xs) = False
&& False foldr (&&) True xs = False
& False True = False
False = False
==============================================================================================
