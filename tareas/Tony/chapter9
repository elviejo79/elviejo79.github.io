
--Exercise 1
imp1 :: Integer -> Integer
imp1 1 = 2
imp1 x = error "1: premise does not apply"

imp2 :: Integer -> Integer
imp2 2 = 3
imp2 x = error "2: premise does not apply"

imp3 :: Integer -> Integer
imp3 3 = 4
imp3 x = error "3: remise does not apply"

s :: [Integer]
s = [1, imp1 (s !! 0), imp2 (s !! 1), imp3 (s !! 2)]

--Si el input es correcto se obtiene [1, 2, 3, 4]


--Exercise 2
imp1_2 :: Integer -> Integer
imp1_2 1 = 2
imp1_2 x = error "imp1: premise does not apply"

imp2_2 :: Integer -> Integer
imp2_2 3 = 4
imp2_2 x = error "imp2: premise does not apply"

s_2 :: [Integer]
s_2 = [0, imp1_2 (s_2 !! 0), imp2_2 (s_2 !! 1)]


--Salida [0,*** Exception: imp1_2: premise does not apply
-- No es una cadena por que en impl2_2 se detiene en 0


--Exercise 3
imp1_3 :: Integer -> Integer
imp1_3 0 = 1
imp1_3 x = error "imp1: premise does not apply"

imp2_3 :: Integer -> Integer
imp2_3 3 = 4
imp2_3 x = error "imp2: premise does not apply"

s_3 :: [Integer]
s_3 = [0, imp1_3 (s_3 !! 0), imp2_3 (s_3 !! 1)]

--------------RESPUESTA-----------------------------
---Salida [0,1,*** Exception: imp2: premise does not apply
--No es una cadena imp2 no se define el parametro 1

--Exercise 4
imp1_4 :: Integer -> Integer
imp1_4 0 = 1
imp1_4 x = error "imp1: premise does not apply"

imp2_4 :: Integer -> Integer
imp2_4 1 = 2
imp2_4 x = error "imp2: premise does not apply"

s_4 :: [Integer]
s_4 = [0, imp1_4 (s_4 !! 1), imp2_4 (s_4 !! 0)]

--No es una cadena, porque en s_4 imp1_4 recibe como parametro 1 en lugar de recibir 0
--s_4 = [0, imp1_4 (s_4 !! 0), imp2_4 (s_4 !! 1)]


--Exercise 5
fun :: Integer -> Integer
fun x = x + 1
n :: [Integer]
n = 0 : map fun n



--Exercise 6
fun6 :: Integer -> Integer
fun6 x = x + 2
s6 :: [Integer]
s6 = 1 : map fun6 s6

--RESPUESTA
-- Salida [1,3,5,7,9,11,13,15,17...]
-- 4 es un número par


--Exercise 7

fun7 :: Integer -> Integer
fun7 x = x + 1
p7 :: [Integer]
p7 = 0 : map fun7 p7
 


--Exercise 8


fun8 :: Integer -> Integer
fun8 x = x * 3
p8 :: [Integer]
p8 = map fun8 [1..]

--Exercise 9
s9 :: [Integer]
s9 = 0 : map ((+) 2) s9

--El número 82 es par


-----------------------Exercise 10------------------------------------------

--Exercise 10. What set is defined by the following?
--s :: [Integer]
--s = 1 : map ((*) 3) s


s10 :: [Integer]
s10 = 1 : map ((*) 3) s10

-- Al ejecutar *Main> s10
-- Se obtiene[1,3,9,27,81...]
-- que son el resultado de multiplicar cada elemento por 3 (1, 1*3=3, 3*3=9, 9*3=27, 27*3=81...)



--Exercise 11
octals = [0..7]
 
newOctalWords :: [Integer] -> [[Integer]]
newOctalWords xs = [x:xs | x <- octals]
 
octalWords = [[x] | x <- octals] ++ (concatMap newOctalWords octalWords)

--Exercise 12
build :: a -> (a -> a) -> [a]
build a f = set  
                where set = a : map f set
builds :: a -> (a -> [a]) -> [a]
builds a f = set
                where set = a : concatMap f set
nextInteger1 :: Integer -> Integer
nextInteger1 x = - x
 
integers1 :: [Integer]
integers1 = build 0 nextInteger1


exercise12 = take 10 integers1




--Exercise 13
nextIntegers2 :: Integer -> [Integer]
nextIntegers2 x = [x + 1, x - 1]
integers2 :: [Integer]
integers2 = builds 0 nextIntegers2


exercise13=take 20 integers2



--Exercise 14

nextIntegers3 :: Integer -> [Integer]
nextIntegers3 x = [x + 1, -(x + 1)]
integers3 :: [Integer]
integers3 = builds 0 nextIntegers3

exercise14=take 10 integers3




--Exercise 15

nextInteger4 :: Integer -> Integer
nextInteger4 x = if x < 0 then x - 1 else x + 1
integers4 :: [Integer]
integers4 = build 0 nextInteger4

exercise15=take 10 integers4
--Al ejecutar *Main>ex15
-- Salida [0,1,2,3,4,5,6,7,8,9]








--Exercise 16
nextIntegers5 :: Integer -> [Integer]
nextIntegers5 x = if x > 0 || x == 0
                     then [x + 1, -(x + 1)]
                     else []
integers5 :: [Integer]
integers5 = builds 0 nextIntegers5



exercise16=take 20 integers5


--Exercise 17
nats :: [Integer]
nats = build 0 (1 +)

negs :: [Integer]
negs = build (-1) (1 -)
ints :: [Integer]
ints = nats ++ negs


-- Does this definition of ints enumerate the integers?
-- Da como salida tanto negativos como positivos

-- Will you ever see the value -1?
-- No






--Exercise 18
twos :: [Integer]
twos = build 0 (2 *)

--Su salida sólo es 0's






--Exercise 19
nats9 = map (+ 1) nats9 ++ [0]

--El caso base aparece al final de la cadena, por lo cual no muestra algún resultado



--Exercise 20
naturals :: [Integer] -> [Integer]
naturals (i:acc) = naturals (i + 1:i:acc)
nats20 :: [Integer]
nats20 = naturals [0]
--La ejecución nunca termina



--Exercise 21
--No, por que el stream genera una cantidad infinita de números antes de llegar al índice






--Exercise 22
-- * n^1 E R
-- * n^(1/m) E R -> n^(1/m+1) E R
-- * Nada esta en R a menos que pueda demostrarse que está en R por un numero finito
--de usos de la base y reglas de inducción.




--Exercise 23-
--1. n^0 E P   por el caso base
--2. Por induccción, n^0 E P -> n1 E P y por Modus Ponens,
--   n^1 E P.
--3. Por inducción, n^1 E P -> n2 E P y por Modus Ponens,
--   n^2 E P.
--4. Por inducción n^2 E P -> n3 E P y por Modus Ponens,
--   n^3 E P.



--Exercise 24

--Si n es un numero positivo multiplo de 2, sí






--Exercise 25
-- El conjunto definido es el conjunto de números impares.
--Caso base: 1 pertenece a S, 1 es impar.
 
--Caso inductivo: Asumiendo que cada número anterior ha sido un non,
--      n mod 2 será 1, entonces usando la regla 3: n + 2 pertenece a S
--      Desde que n es impar, n + 2 también es impar.




--Exercise 2
--Por regla (1), 0 E S
--Por regla (2) 0 E S -> 2 E S  y por Modus Ponens 2 E S.
--Por regla (2) 2 E S -> 4 E S so 4 E S.

--Exercise 27

--1. "" E Y Y S
--2. "" E Y Y S -> "yy" E Y Y S y  Modus Ponens, "yy" E Y Y S.
--3. "yy" E Y Y S -> "yyyy" E Y Y S y  por Modus Ponens, "yyyy" E Y Y S.




--Exercise 28

exercise28 = "" : map ('z':) exercise28




--Exercise 29
--1. "" E SS
--2. ss E SS /\ length ss < n ->' ': ss E SS
--3. SS es vacío a menos que sea un uso infinito de las reglas 1 y 2



--Exercise 30
spaces :: Int -> [String]
spaces 0 = [""]
spaces n = take n (repeat ' ') : spaces (n - 1)

-- Exercise 31
--1. N - {0} E SSN
--2. (N - {n}) E SSN -> (N - {n + 1} E SSN
--3. SSN es vacío a menos que se use un número infinito las reglas 1 y 2






--Exercise 32

--1. I - {1} E SSI-
--2. I- {-1} -> I - {-2} E SSI-
--3. I - {-2} -> I - {-3} E SSI-
--4. MP I - {-3} E SSI-






--Exercise 33

--1. -1 E ONI
--2. -1 E ONI -> -3 E ONI entonces -3 E ONI
--3. -3 E ONI -> -5 E ONI entonces -5 E ONI
--4. -5 E ONI -> -7 E ONI entonces -7 E ONI





--Exercise 34
ni = -1 : map decrement ni
              where decrement x = x - 1





--Exercise 35

-- No se visualiza por que debe de quedar con 0, pero es un número infinito por lo cual no se puede ver




--Exercise 36
-- El conjunto {0,1}
-- 1 E S -> 1 - 1 = 0 E S
-- 0-0 = 0 E S

