-- Exercise 1. Define a Haskell datatype Tree1 for a tree that contains a character
-- and an integer in each node, along with exactly three subtrees.

data BinTree a= Leaf | Node a (BinTree a) (BinTree a) deriving Show
tree1 :: BinTree (Char,Integer)
tree1 = Node ('a',1) Leaf Leaf

--Exercise 2. Define a Haskell datatype Tree2 for a tree that contains an integer
--in each node, and that allows each node to have any number of subtrees.

-- data BinTree a= Leaf | Node a (BinTree a) (BinTree a) deriving Show
tree2 :: BinTree Integer
tree2 = Node 3 (Node 4
					(Node 1 Leaf Leaf)
					(Node 6 Leaf Leaf))
				(Node 7
					(Node 8 Leaf Leaf)
					(Node 9 Leaf Leaf))

--Exercise 3. Calculate the inorder traversal of tree3.

-- tree3 :: BinTree a -> [a]
-- tree3 Leaf = []
-- tree3 (Node 3 (Node 4 Leaf Leaf) Leaf) 
-- = tree3 (Node 4 Leaf Leaf) ++ [3] ++ tree3 Leaf					
-- = (tree3 leaf ++ [4] ++  tree3 leaf) ++ [3] + []
-- = ([]++[4]++[]) ++ [3] ++ []
-- =[4,3]


-- Exercise 4. Suppose that a tree has type BinTree a, and we have a function f
-- :: a -> b. Write a new traversal function inorderf :: (a->b) ->
-- BinTree a -> [b] that traverses the tree using inorder, but it applies f
-- to the data value in each node before placing the result in the list. For
-- example, inorder tree6 produces [1, 2, 3, 4, 5, 6, 7], but inorderf (2*)
-- tree6 produces [2, 4, 6, 8, 10, 12, 14].

inorderf :: (a -> b) -> BinTree a -> [b] 
inorderf f Leaf = []
inorderf f (Node x t1 t2) = inorderf f t1 ++ [f x] ++ inorderf f t2
--         *igual*        = map f(inorder (Node x t1 t2)) 

-- Exercise 5. Define two trees of size seven, one with the largest possible height
-- and the other with the smallest possible height.

--tree5 :: BinTree Int
-- tree5 = Node 1 (Node 2 
	--				Leaf
	--				(Node 3 
	--					Leaf
	--					(Node 4 
	--						Leaf 
	--						(Node 5 
	--							Leaf 
	--							(Node 6 
	--								Leaf 
	--								(Node 7 Leaf Leaf)))))
	--			Leaf)	


--tree5_1 :: BinTree Int
--tree5_1 = Node 1 (Node 2 
--						(Node 3
--							(Node 5 
--								(Node 9  
--									(Node 13 Leaf Leaf)
--									(Node 14 Leaf Leaf))
--								(Node 77
--									(Node 78 Leaf Leaf)
--									(Node 79 Leaf Leaf)))
--							(Node 6
--							    (Node 10  
--							     	(Node 15 Leaf Leaf)
--							     	(Node 16 Leaf Leaf))
--							    (Node 50 
--							    	(Node 51 Leaf Leaf)
--							    	(Node 52 Leaf Leaf)))
--						(Node 4
--							(Node 7
--								(Node 11 
--									(Node 40 Leaf Leaf)
--									(Node 41 Leaf Leaf)) 
--							(Node 8
--							    (Node 12 
--							    	(Node 42 Leaf Leaf)
--							    	(Node 43 Leaf Leaf)))))
--				 (Node 70
--						(Node 3
--							 (Node 20 Leaf Leaf)
--							 (Node 30 Leaf Leaf))
--						(Node 2
--							 (Node 40 Leaf Leaf)
--							 (Node 50 Leaf Leaf)))))	








-- Exercise 6. Suppose that the last equation of the function balanced were
-- changed to the following: balanced (BinNode x t1 t2) = balanced
-- t1 && balanced t2. Give an example showing that the modified function
-- returns True for an unbalanced tree.

balanced1 :: BinTree a -> Bool
balanced1 Leaf = True
balanced1 (Node x t1 t2) = balanced1 t1 && balanced1 t2


-- Exercise 7. Suppose that the last equation of the function balanced were
-- changed to the following: 

--balanced (BinNode x t1 t2) = height t1  == height t2. 

--Give an example showing that the modified function returns True for an unbalanced tree.

height :: BinTree a -> Integer
height Leaf = 0
height (Node x t1 t2) = 1 + max (height t1) (height t2)

balanced :: BinTree a -> Bool
balanced Leaf = True
balanced (Node x t1 t2) =  height t1  == height t2


-- Exercise 8. Define a function mapTree that takes a function and applies it to
-- every node in the tree, returning a new tree of results. The type should
-- be mapTree :: (a->b) -> BinTree a -> BinTree b. This function
-- is analogous to map, which operates over lists.


mapTree :: (a->b) -> BinTree a -> BinTree b
mapTree f Leaf = Leaf
mapTree f (Node x t1 t2) =Node(f x) (mapTree f t1) (mapTree f t2) 


-- Exercise 9. Write concatTree, a function that takes a tree of lists and concatenates
-- the lists in order from left to right. For example,

-- concatTree (Node [2] (Node [3,4] Tip Tip)
-- 						(Node [5] Tip Tip))
-- ==> [3,4,2,5]

concatTree1 ::  BinTree [a] -> [a]
concatTree1 Leaf = []
concatTree1 (Node x t1 t2)= concatTree1 t1 ++ x ++ concatTree1 t2


--Exercise 10. Write zipTree, a function that takes two trees and pairs each
--the corresponding elements in a list. Your function should return Nothing
--if the two trees do not have the same shape. For example,
--zipTree (Node 2 (Node 1 Tip Tip) (Node 3 Tip Tip))
--(Node 5 (Node 4 Tip Tip) (Node 6 Tip Tip))
-- ==> Just [(1,4),(2,5),(3,6)]



--Exercise 11. Write zipWithTree, a function that is like zipWith except that
--it takes trees instead of lists. The first argument is a function of type
--a->b->c, the second argument is a tree with elements of type a,and the
--third argument is a tree with elements of type b. The function returns a
--list with type [c].

--zipWithTree :: BinTree [a]-> [a]
--zipWithTree Leaf =[]
--zipWithTree (Node x t1 t2) = zipWithTree t1 ++ x ++ zipWithTree t2

zipWithTree :: (a -> b -> c) -> BinTree a -> BinTree b -> [c]
zipWithTree f t1 Leaf = []
zipWithTree f Leaf t2 = []
zipWithTree f (Node a t1 t2) (Node b t3 t4) =  zipWithTree f t1 t3 ++ [f a b] ++ zipWithTree f t2 t4 


-- Exercise 12. Write appendTree, a function that takes a binary tree and a
-- list, and appends the contents of the tree (traversed from left to right) to
-- the front of the list. For example,
-- appendTree (BinNode 2 (BinNode 1 BinLeaf BinLeaf)
--   					 (BinNode 3 BinLeaf BinLeaf))
-- [4,5]
-- evaluates to [1,2,3,4,5]. Try to find an efficient solution that minimises
-- recopying.

inorder :: BinTree a -> [a]
inorder Leaf = []
inorder (Node x t1 t2)= inorder t2 ++ [x] ++ inorder t2

appendTree :: BinTree a -> [a] -> [a]
appendTree Leaf [] = []
appendTree (Node x t1 t2) ys = inorder t1 ++ [x] ++ inorder t2 ++ ys
