<meta charset="utf-8" emacsmode="-*- markdown -*-">
<link rel="stylesheet" href="style.css">
<link rel="stylesheet" href="https://casual-effects.com/markdeep/latest/journal.css">


    **Testorial: An executable Tutorial**
    By [Alejandro Garcia](mailto:agarciafdz@gmail.com)

![Author surveying the terrain ](./images/author_terrain.png)

When you are learning a new technology, library, or programming language have you felt the excitement of finding the perfect tutorial.
The one that explains what you want to learn in a voice that you can understand with an example that almost perfectly matches your needs.
Only to feel the frustration of discovering that many instructions in the tutorial are obsolete no longer works or maybe they never did.

Well, as a Content Engineer let me tell you that it is never my intention to write documentation that goes stale.
It's just that there are many moving parts,
So invariably a section of a good tutorial will always become obsolete almost the moment we publish it.
It's our continuous fight against [bit rot](https://en.wikipedia.org/wiki/Software_rot).

However, from the field of DevOps we have techniques of Continuous Integration that helps fight bit rot in Software.
And we can use the same techniques in our documentation.
By monitoring our source testorial, and detecting changes we can anticipate parts of our tutorial that will be need to be updated.

And if this wasn't enough reason to justify the effort to write testorials.
We need to consider a new Learner: Large Language Models (LLMs)
LLMS will learn from the documentation that we write.
So our documentation *can't be a hallucination* it *must be correct* so that the LLM,
Can learn the correct way to do things.

This tutorial is for Authors, Content Engineers and Technical Writers,
that want to
fight bit rot,
don't waste their Learner's time,
and provide more value to their organization by doing integration tests
that their software must run.

Testorial
: A Testable Tutorial
: Is a Tutorial written so that  humans can comprehend,
: that also works as a test in a Continuous Integration (CI) pipeline.
: Becoming valuable for both your Learners and Quality Assurance (QA) Team.
: synonym: executable documentation
: related: literate programming, devops

Tutorial
: A goal oriented article, written so that a Learner can aquire a new skill.
: Every Testorial is a Tutorial, but not every Tutorial is a Testorial.

# Why aren't Docs-as-test more popular.

Given that the movement Docs-as-Code has been active since at least 2015[fn:1].
And it's historical precedent Literate Programming, was invented by Donald Knuth in 1984[fn:2]  .
It should be more popular and it isn't.

If we just search online: Why isn't literate programming more popular?
We would a find that common reason is that:

> The intersection of people that are good programmers
> and good writers at the same time is pretty small.

I find this is a good point, for general programmers.

But for technical writers, it's the starting position!

Traditional Technical Writing has been seen as a person that can wear two hats:

- Programmer:
  - Read code, libraries, products
  - Experiments and learns
- Writer
  - Writes documentation
  - Edits documentation

![A Tech Writer is the rare intersection between a Programmer and a Writer](./images/venn_programmer_writer.svg)

But Even though a Technical Writer has the skills of Programmer and a Writer.
We don't see frequently executable documentation or testorials.
And I think it is because
Testorial asks the Author to wear a *third hat*:

- Tester
 - Automatize test cases
 - Monitors

And if just writing is already difficult,
writing, programming and testing is as difficult as finding a unicorn.

![A person that can wear all three hats is as rare as unicorn](./images/venn_programmer_writer_tester.svg)


But now it's 2026 And we can count on the help of LLMs!
which has dramatically increased the size of the intersection.

So doesn't matter how you started,
If you were writer fascinated by computers and became a technical writer.
Or you were a DevOps engineer that you learned you love of writing later in life, like me.
LLMs can help us become the unicorn at the intersection of the three hats needed to do Docs-as-Tests

![With LLMs it is easier to become a unicorn, or Author of estorials](./images/venn_unicorn.svg)

# A map of the terrain

We have always had to consider the audience when writing a piece.
Now we need to consider three different audiences:

A Learner
: A human or LLM using your article to develop a new skill.

A DevOps engineer
: A person in your organization that doesn't care about your testorial, except that it will help him with QA for the whole project.

An Author (yourself)
: You need consider your own environment, deadlines, etc. and the ones of your audience.

And for each element of our audince we need to consider distinct levels of understanding.

Context level
: Is under what circunstances (outside its control) are we writing.

Artifact level
: the actual thing (tutorial, testorial, workflow) that the person can maniplate.

Parts level
: Every artifact, will be integrated from sub-parts and you need to think clearly about them considering the audience.


Thinking this way, gives us a map of the terran that we are going to traverse while writing.

## Nine windows to write a testorial

Considering our Audiences and the Levels of context we need to understand we can map our article as:

*********************************************************************************************************
*                     ┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ Audience ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓    *
*                                                                                                       *
*                                Author                  DevOps                  Learner                *
*    ⎡                ╔═════════════════════════╦══════════════════════════╦════════════════════════╗   *
*    ⎢                ║                         ║                          ║                        ║   *
*    ⎢                ║                         ║                          ║                        ║   *
*    ⎢       Context  ║          1st            ║          2nd             ║        3rd             ║   *
*    ⎢                ║                         ║                          ║                        ║   *
*    ⎢                ║                         ║                          ║                        ║   *
*    ⎢                ║                         ║                          ║                        ║   *
*    ⎢                ║                         ║                          ║                        ║   *
*    ⎢                ╠═════════════════════════╬══════════════════════════╬════════════════════════╣   *
*    ⎢                ║                         ║                          ║                        ║   *
*    ⎢                ║                         ║                          ║                        ║   *
* Level     Artifact  ║                         ║                          ║                        ║   *
*    ⎢                ║          4th            ║           5th            ║         6th            ║   *
*    ⎢                ║                         ║                          ║                        ║   *
*    ⎢                ║                         ║                          ║                        ║   *
*    ⎢                ║                         ║                          ║                        ║   *
*    ⎢                ╠═════════════════════════╬══════════════════════════╬════════════════════════╣   *
*    ⎢                ║                         ║                          ║                        ║   *
*    ⎢                ║                         ║                          ║                        ║   *
*    ⎢                ║                         ║                          ║                        ║   *
*    ⎢         Parts  ║         7th             ║                          ║                        ║   *
*    ⎢                ║                         ║                          ║                        ║   *
*    ⎢                ║                         ║                          ║                        ║   *
*    ⎢                ║                         ║                          ║                        ║   *
*    ⎣                ╚═════════════════════════╩══════════════════════════╩════════════════════════╝   *
*                                                                                                       *
*********************************************************************************************************

Now with this map we can make sense of what we are writing for whom, when.

# 1st Level: Context

Let's start by understanding the Context on which each of our Audience operate
The context is very important since most of the time we cannot control it.
And it is acutally a constraint.



And the main Context that we need to focus on is the one for you the Author:

## A Learners Context
This is the most obvious one, we need to be mindful of our Learners Context.
+ What is their previous experience?
+ What constrains could their employer have?
+ What operating system are they using?
and so on.


*********************************************************************************************************
*                                                                                                       *
*                                                                                                       *
*                                Author                  DevOps                  Learner                *
*                     ╔═════════════════════════╦══════════════════════════╦════════════════════════╗   *
*                     ║                         ║                          ║                        ║   *
*                     ║                         ║                          ║                        ║   *
*            Context  ║                         ║                          ║ Previous Experience?   ║   *
*                     ║                         ║                          ║ Job Constraints?       ║   *
*                     ║                         ║                          ║ Operating System?      ║   *
*                     ║                         ║                          ║                        ║   *
*                     ║                         ║                          ║                        ║   *
*                     ╠═════════════════════════╬══════════════════════════╬════════════════════════╣   *
*                     ║                         ║                          ║                        ║   *
*                     ║                         ║                          ║                        ║   *
*           Artifact  ║                         ║                          ║                        ║   *
*                     ║                         ║                          ║                        ║   *
*                     ║                         ║                          ║                        ║   *
*                     ║                         ║                          ║                        ║   *
*                     ║                         ║                          ║                        ║   *
*                     ╠═════════════════════════╬══════════════════════════╬════════════════════════╣   *
*                     ║                         ║                          ║                        ║   *
*                     ║                         ║                          ║                        ║   *
*                     ║                         ║                          ║                        ║   *
*              Parts  ║                         ║                          ║                        ║   *
*                     ║                         ║                          ║                        ║   *
*                     ║                         ║                          ║                        ║   *
*                     ║                         ║                          ║                        ║   *
*                     ╚═════════════════════════╩══════════════════════════╩════════════════════════╝   *
*                                                                                                       *
*********************************************************************************************************
[Figure [learner_context]: The Learners context, guides the depath and tone of our tutorial]

## DevOps Context

On this context we need to understand that the DevOps and QA Team, have setup a Continious Integration (CI) pipeline.
The CI on every change, takes the content of the source code repository,
executes tests on it and if the tests are correct,
publishes a new version of our software into production.

All of this happens inside virtual computers called Containers, so that we don't have to
This pipeline is crucial, since we will integrate the testorials as parts of the pipeline in the following sections.

*********************************************************************************************************
*                                                                                                       *
*                                                                                                       *
*                                Author                  DevOps                  Learner                *
*                     ╔═════════════════════════╦══════════════════════════╦════════════════════════╗   *
*                     ║                         ║                          ║                        ║   *
*                     ║                         ║                          ║                        ║   *
*            Context  ║                         ║ What is the CI pipeline? ║ Previous Experience?   ║   *
*                     ║                         ║                          ║ Job Constraints?       ║   *
*                     ║                         ║ GitHub Runner (Container)║ Operating System?      ║   *
*                     ║                         ║                          ║                        ║   *
*                     ║                         ║                          ║                        ║   *
*                     ╠═════════════════════════╬══════════════════════════╬════════════════════════╣   *
*                     ║                         ║                          ║                        ║   *
*                     ║                         ║                          ║                        ║   *
*           Artifact  ║                         ║                          ║                        ║   *
*                     ║                         ║                          ║                        ║   *
*                     ║                         ║                          ║                        ║   *
*                     ║                         ║                          ║                        ║   *
*                     ║                         ║                          ║                        ║   *
*                     ╠═════════════════════════╬══════════════════════════╬════════════════════════╣   *
*                     ║                         ║                          ║                        ║   *
*                     ║                         ║                          ║                        ║   *
*                     ║                         ║                          ║                        ║   *
*              Parts  ║                         ║                          ║                        ║   *
*                     ║                         ║                          ║                        ║   *
*                     ║                         ║                          ║                        ║   *
*                     ║                         ║                          ║                        ║   *
*                     ╚═════════════════════════╩══════════════════════════╩════════════════════════╝   *
*                                                                                                       *
*********************************************************************************************************
[Figure [devops_context]: A DevOps context, inorms what is the CI pipeline and the publishing process]

## An Author's Context

Now lets talk about you, the Author and your Context.

Probably your organization already has setup a Content Management System (CMS).
And you need to understand the workflows that will transform (publish) the testorial to a tutorial.

Since a testorial is also code, and code is plain text
Any CMS that works with plain text formas like Markdown, Asciidoc, Org-mode will do.
This category is commonly called Static Site Generators.

Some SSG that work well are:
[Docusaurus](https://docusaurus.io),
[GitHub Pages](https://docs.github.com/en/pages/quickstart) Or my personal favorite
[MarkDeep](https://casual-effects.com/markdeep/)

In this tutorial we will assume your using GitHub Pages as your CMS.
Since it's pretty common and it integrates with GitHub Actions, that is a Continuous Integration pipeline.

Probably your organization already has configured GitHub Pages.
You just need to understand on which repository on which folder you need to save your testorial markdown document.
But, in case it is not configured you can check the section [Appendix: Configuring GitHub Pages] Configuring GitHub Pages.


What is important to understand is the publishing process of GitHub Pages

### GitHub Pages publishing process

In GitHub Pages the process of publishing is:

1. Create or Modify Markdown document.
2. git commit & git push
3. Wait for GitHub Workflow to finish.
4. Review modifications on your website.

You can monitor the state the of the GitHub Workflow on the page.

Observe that the workflow it's on yellow while it is running.

You can even check the detail instructions that it is executing.

When it finally turns to green means your new page is published.

![Your workflow is in yellow while it runs and green once it passes](./images/workflows.png)

### Tracing the publishing process

Now that we understand the GitHub Pages publishing process.
We can trace how it works in our map of writing.

*********************************************************************************************************
*                                                                                                       *
*                                                                                                       *
*                                Author                  DevOps                  Learner                *
*                     ╔═════════════════════════╦══════════════════════════╦════════════════════════╗   *
*                     ║                         ║                          ║                        ║   *
*            Context  ║ CMS - GitHub Pages      ║                          ║                        ║   *
*                     ║        |                ║                          ║                        ║   *
*                     ║        |                ║                          ║                        ║   *
*                     ║     dictates            ║                          ║                        ║   *
*                     ║    organization         ║                          ║                        ║   *
*                     ╠════════|════════════════╬══════════════════════════╬════════════════════════╣   *
*                     ║        |                ║                          ║                        ║   *
*           Artifact  ║        v                ║                          ║                        ║   *
*                     ║ Markdown Document ---git push--> GH Workflow ---publish--> Tutorial         ║   *
*                     ║                         ║                          ║                        ║   *
*                     ║                         ║                          ║                        ║   *
*                     ║                         ║                          ║                        ║   *
*                     ╠═════════════════════════╬══════════════════════════╬════════════════════════╣   *
*                     ║                         ║                          ║                        ║   *
*                     ║                         ║                          ║                        ║   *
*                     ║                         ║                          ║                        ║   *
*              Parts  ║                         ║                          ║                        ║   *
*                     ║                         ║                          ║                        ║   *
*                     ║                         ║                          ║                        ║   *
*                     ║                         ║                          ║                        ║   *
*                     ╚═════════════════════════╩══════════════════════════╩════════════════════════╝   *
*                                                                                                       *
*********************************************************************************************************
[Figure [gh_pages_workflow]: GitHub Pages pbublishing workflow]

# 2nd Level the Artifact

In the previous diagram we saw that at the Artifact level works like a single pipeline.
Now on this section we are going to cover that pipeline in more detail.

## A Learners Artifact: The tutorial

Let's start with the end in mind.
Let's look at the tutorial that our Learner will read:


<div class="example">
<div class="view">
Browser
<div class="window browser">
<div class="buttons"></div>
<div class="tab">Example</div>
<div class="menu"> <- -> ⟳ <div class="url">/Users/morgan/example.md.html</div></div>
<iframe src="hello_world.html" content="text/html;charset=UTF-8"></iframe>
</div></div></div>


In our 9 windows framework we are here:

*********************************************************************************************************
*                                                                                                       *
*                                                                                                       *
*                                Author                  DevOps                  Learner                *
*                     ╔═════════════════════════╦══════════════════════════╦════════════════════════╗   *
*                     ║                         ║                          ║                        ║   *
*                     ║                         ║                          ║                        ║   *
*                     ║                         ║                          ║                        ║   *
*            Context  ║                         ║                          ║                        ║   *
*                     ║                         ║                          ║                        ║   *
*                     ║                         ║                          ║                        ║   *
*                     ║                         ║                          ║                        ║   *
*                     ╠═════════════════════════╬══════════════════════════╬════════════════════════╣   *
*                     ║                         ║                          ║ ╭───────────────────╮  ║   *
*                     ║                         ║                          ║ │    Browser        │  ║   *
*           Artifact  ║                         ║                          ║ ├───────────────────┤  ║   *
*                     ║                         ║                          ║ │                   │  ║   *
*                     ║                         ║                          ║ │    Tutorial       │  ║   *
*                     ║                         ║                          ║ │                   │  ║   *
*                     ║                         ║                          ║ ╰───────────────────╯  ║   *
*                     ╠═════════════════════════╬══════════════════════════╬════════════════════════╣   *
*                     ║                         ║                          ║                        ║   *
*                     ║                         ║                          ║                        ║   *
*                     ║                         ║                          ║                        ║   *
*              Parts  ║                         ║                          ║                        ║   *
*                     ║                         ║                          ║                        ║   *
*                     ║                         ║                          ║                        ║   *
*                     ║                         ║                          ║                        ║   *
*                     ╚═════════════════════════╩══════════════════════════╩════════════════════════╝   *
*                                                                                                       *
*********************************************************************************************************
[Figure [learner_artifact]: A Learner reads the tutorial]

## Author's Artifact: the Testorial

In the previous section we saw what a Student would read.
For you the the Testorial looks like a markdown source code.

~~~ markdown
(insert hello_world.html here)
~~~

Notice that we have marked the instructions we expect the student to type like `@localhost $`
How can we make sure that the instructions are correct?

### Snapshot testing

Snapshot testing are category of tools that execute a command and verify the output of the command matches the expectation.

In our case we will use `clitest for posix`

### Installing clitest

Installing `clitest` is as easy as:

~~~ bash
@author $ curl -sOL https://raw.githubusercontent.com/aureliojargas/clitest/master/clitest
@author $ chmod +x clitest
@author $ mv clitest ~/.local/bin
@author $ clitest --version
@author clitest 0.5.0
~~~

### Listing the commands in hello_world.md

Now lets use `clitest` to view what commands are in our tutorial

~~~ bash
@author $ clitest --list --prefix '@learner ' ./hello_world.html
@author #1	echo "hello world"
@author #2	echo "hello world" | tr '[:lower:]' '[:upper:]'
~~~

+ Use `--list` to show the commands that can execute in the tutorial.
+ The parameter `--prefix '@learner'` specifies how the executable lines are prefixed.
+ The #1 and #2 show what are the commands that `clitest` identified as possible.
+ #1 and #2 are the test cases in our testorial /test suite/

!!! Tip
    Is important to make sure that `--list` finds all the commands that you expect the testorial to execute.

To actually execute the tests you just need to remove the `-- list` flag

~~~{.bash}
@author $ clitest --prefix '@learner ' ./hello_world.html
@author #1	echo "hello world"
@author #2	echo "hello world" | tr '[:lower:]' '[:upper:]'
@author OK: 2 of 2 tests passed

~~~

Now we get the report `OK: 2 of 2 tests passed`.

This testorial is /pure/, it doesn't change any files in our computer.
So you can repeat it as many times as you wish.

Try it, just execute `clitest` again.

~~~{.bash}
@author $ clitest --prefix '   :' ./docs/hello_world.md
@author exit 0
~~~

It will run again the tests.
The comment `exit 0`, means that the command executed correctly,
and we don't care about the literal output,


### Where does  `clitest` fit in our nine windows framework?

*********************************************************************************************************
*                                                                                                       *
*                                                                                                       *
*                                Author                  DevOps                  Learner                *
*                     ╔═════════════════════════╦══════════════════════════╦════════════════════════╗   *
*                     ║                         ║                          ║                        ║   *
*                     ║                         ║                          ║                        ║   *
*            Context  ║                         ║                          ║                        ║   *
*                     ║                         ║                          ║                        ║   *
*                     ║                         ║                          ║                        ║   *
*                     ║                         ║                          ║                        ║   *
*                     ║                         ║                          ║                        ║   *
*                     ╠═════════════════════════╬══════════════════════════╬════════════════════════╣   *
*                     ║   .--- clitest <--.     ║                          ║ ╭───────────────────╮  ║   *
*                     ║   |               |     ║                          ║ │    Browser        │  ║   *
*           Artifact  ║  executes        fix    ║                          ║ ├───────────────────┤  ║   *
*                     ║   |               |     ║                          ║ │                   │  ║   *
*                     ║   v               |     ║                          ║ │    Tutorial       │  ║   *
*                     ║   testorial.markdown    ║                          ║ │                   │  ║   *
*                     ║                         ║                          ║ ╰───────────────────╯  ║   *
*                     ╠═════════════════════════╬══════════════════════════╬════════════════════════╣   *
*                     ║                         ║                          ║                        ║   *
*                     ║                         ║                          ║                        ║   *
*                     ║                         ║                          ║                        ║   *
*              Parts  ║                         ║                          ║                        ║   *
*                     ║                         ║                          ║                        ║   *
*                     ║                         ║                          ║                        ║   *
*                     ║                         ║                          ║                        ║   *
*                     ╚═════════════════════════╩══════════════════════════╩════════════════════════╝   *
*                                                                                                       *
*********************************************************************************************************
[Figure [author_artifact]: An author makes its testorial executable by clitest]

## DevOps Engineer Artifact

Now that the test can be reproduce locally,
we need to think, How it is going to be executed on the Continuous Integration server?

### GitHub Actions

Is a Continuous Integration server provided by GitHub.
It has two main components:

+ Runners: Virtual containers that execute your code.
+ Workflows: instructions on how to configure said containers and how to execute your code.

### GitHub Workflow

We will configure a workflow that can execute the testorial as we can now do locally with `clitest`.

Look at this suggested workflow

(embed ../.github/workflows/execute_testorials.yml height=100px here)

[Listing [execute_testorial_yml]: ./.github/workflows/execute_testorials.yml]


(1) Name of our workflow.

(2) This is the event that will trigger the execution of our workflow.

(3) In particular we want to trigger the execution from the GitHub User Interface.

(4) This is the Operating system where the tests are going to run.

This workflow will execute on every commit, but for demonstration purposes go to where you have this tutorial stored.
Then GitHub Workflows click on Execute wait a few minutes.
And see that it is in *green* meaning all the tests executed correctly.


### Commit your execute_testarials workflow

Now we are ready to include this tutorial as part of the CI pipeline.
This will need  approval from your DevOps department
Your `testorial.markdown` and `execute_testolias.yml` workflow is all the documentation they need to include the testorials execution as part of the CI process.

Perhaps the DevOps team will decide to change the trigger so that instead of on every commit, it's on every pull request.

!!! Warning
    Now you will get notified when a code change, or a library update breaks your testorial.
    So now you have a new responsibility, to keep your testorials updated.
    But better be you, the Author, than your frustrated readers.


> "The reward for work well done is the opportunity to do more."
>
>       -- Jonas Salk, inventor of the polio vaccine

### Tracing the CI pipeline in the nine Windows

*********************************************************************************************************
*                                                                                                       *
*                                                                                                       *
*                                Author                  DevOps                  Learner                *
*                     ╔═════════════════════════╦══════════════════════════╦════════════════════════╗   *
*                     ║                         ║                          ║                        ║   *
*                     ║                         ║                          ║                        ║   *
*            Context  ║                         ║                          ║                        ║   *
*                     ║                         ║                          ║                        ║   *
*                     ║                         ║                          ║                        ║   *
*                     ║                         ║                          ║                        ║   *
*                     ║                         ║                          ║                        ║   *
*                     ╠═════════════════════════╬══════════════════════════╬════════════════════════╣   *
*                     ║ .--- clitest <--.       ║  .--> GH Workflow        ║ ╭───────────────────╮  ║   *
*                     ║ |               |       ║  |     |                 ║ │    Browser        │  ║   *
*           Artifact  ║ executes       fix      ║  |   execute             ║ ├───────────────────┤  ║   *
*                     ║ |               |       ║  |     |                 ║ │                   │  ║   *
*                     ║ v               |       ║  |     v                 ║ │    Tutorial       │  ║   *
*                     ║ testorial.markdown---gh push   clitest? ---publish-->│                   │  ║   *
*                     ║                         ║                          ║ ╰───────────────────╯  ║   *
*                     ╠═════════════════════════╬══════════════════════════╬════════════════════════╣   *
*                     ║                         ║                          ║                        ║   *
*                     ║                         ║                          ║                        ║   *
*                     ║                         ║                          ║                        ║   *
*              Parts  ║                         ║                          ║                        ║   *
*                     ║                         ║                          ║                        ║   *
*                     ║                         ║                          ║                        ║   *
*                     ║                         ║                          ║                        ║   *
*                     ╚═════════════════════════╩══════════════════════════╩════════════════════════╝   *
*                                                                                                       *
*********************************************************************************************************
[Figure [devops_artifact]: How a testorial gets executed and becomes a tutorial]


# 3rd level: Components

Now that we have completed the hello world.

We will create a 2 nd tutorial, this tutorial will create an actual file that gets stored in the computer.
Having this effect doesn't let us run and re-run the tutorial with `clitest` as easy as before.
Instead we need to create *isolation*.

## As a Learner

Now let's suppose we want to create a bash script that says hello world.

### Orienting ourselves in the map

Executing hi.sh from bash is something that happens in the system of the student,
while reading tutorial: ./docs/hello_wrold.html in their browser.
The script hi.sh is a sub part of the tutorial for the student.

|              | Reader (Student)               | Author (Tech writer, Content  Engineer) | DevOps                       |
|--------------|--------------------------------|-----------------------------------------|------------------------------|
| Super System |                                | CMS - GitHub Pages                      | CI Pipeline (GitHub Actions) |
| System       | *Execute hi.sh*                | clitest                                 | Testorial.yml workflow       |
| Sub-system   | *Save hi.sh in the filesystem* |                                         |                              |

### 2nd example: hi.sh
One of the advantages of programs like bash.
Is that the same instructions that you write as human,
can be used to write a script,
that the computer can execute almost exactly as if a human was typing them in the screen.

Those programs are called: scripts.


------

Let's suppose we want to create a bash script,
that tell us: "Hello World"
So it is the same as we did typing the instructions,
but now it will be a script that executes them.


~~~{.bash .cb_save=./hi.sh}
#!/bin/env bash

echo "Hello World"


~~~

Once we store the file and name it: `hi.sh`
you need to give it permissions to be used as a program.
for that you use the command `chmod`

~~~
   :$ chmod +x ./hi.sh
~~~

What this means is add (+) the executable permission to the `./hi.sh` file.
Which makes it an executable program you can use like:


~~~
    :$ ./hi.sh
    Hello World
~~~

As you can see now, the computer is executing the same instructions,
you typed before.
But now it's a program.



------

## As a Teacher

Now if we run the "testorial" tutorial
on first instance we might get lucky

and be able to execute it:

~~~
  :$ clitest --prefix '   :' ./hello_script.md
~~~

But if we execute it a second time.
We will get the error that the file already exists:


~~~
  :$ clitest --prefix '   :' ./hello_script.md #=> exit -3
~~~

Now there are several ways we could handle this:

1. We could write a code block in the beginning of our tutorial, specifying that the script shouldn't exist before execution.
   That would be a pre-condition.
2. Make the tutorial clean after it's execution. So deleting the created files, so that the next time is executed the state is known.
3. Make the testorial execute on a temp directory every time to create isolation. This is the approach favored by the tool `prysk` and `cram` that are other snapshot-testing tools like `clitest` the one we are using now.
4. And finally make our testorial execute on an *isolated* environment.

### Orienting ourselves in the map



|              | Reader (Student) | Author (Tech writer, Content  Engineer)      | DevOps                 |
|--------------|------------------|----------------------------------------------|------------------------|
| Super System |                  | clitest, act, actlint and CMS - GitHub Pages | GitHub Actions..       |
| System       | Executing hi.sh  | ./docs_source/hello_world.md                 | Testorial.yml workflow |
| Sub-system   | the script hi.sh | hi.sh                                        |                        |

### Act

So to re-create the students environment in our tutorial we would use a Docker image,
that looks a lot like a the system that our Continuous Integration team uses.

So that would be using act`.

you can verify that you have act installed by:

~~~
  $ act --version
  act version 0.2.67
~~~

Now let's create a GitHub workflow that we can use to execute our tutorial as a test.

We will use the help of Claude Code to do this but any of your  agentic coding tutorials can do it.

~~~bash

% claude --print "Can you generate .github workflow that using the latest ubuntu version install clitest and executes with basic_nushell_tutorial.md ?
...
~~~


You can validate the generated workflow with actionlint[fn:5]

~~~
% claude --print "Validate .github/workflow/shelldocs.yml using actionlint and correct any error"
...
~~~

And that's it.
Now you have setup the environment that we will use to run the tests.

#### Now run the test in our container
now finally we ca locally run the tutorial repetitive tutorial.
Even if it creates files, or changes databases, etc.
It can run repetitively.

~~~
   ~$ act list
~~~

Will give you the list of jobs to run.


~~~
   ~$ act jobs test_hello_world_tutorial~
~~~

Now we are ready to make this tutorial part of our Continuous Integration Tutorial.

## As a DevOps Engineer

Now Fortunately for us,
Our Act container has the same structure as the one of GitHub Actions.
Therefore the execution of our new tutorial doesn't require any change.
Just upload hello_script.md tutorial
And see how it is running in the GitHub Workflows tab.

# Level 3: Invisible Commands

Now for our final variation on a tutorial.

Let's think of commands that we want to be executed as part of our test,
but we don't want to be actually read by the Student.

This make us create a new kind of publishing step in our tutorials.
One Step to execute the output

## As a Student

Some tutorial need to show changes over time for the same time.

As developers the tool that we use to show the differences between two versions of the same file.

so a tutorial to shows changes over time would look like this:

### 3rd Example Hello your_name

------

Let's suppose we want to create a bash script,
that tell us: "Hello $your_name"
Where $your_name is parameter we send from the command line.

Well in that case we would need to write a script like this:


~~~
#!/bin/env bash

+ name:-$1:'World'
+ echo "Hello $name"
- echo "Hello World"

~~~

What the lines with the `+` sign mean that line was added.
and the ones with `-` mean that line was deleted.
And when you see two very similar lines one with the `+` and one with the `-` it means actually the line was replaced.
like the "Hello World" being replaced by "Hello $name".

Now save your file again as hi.sh. And Execute it like:

~~~
    :$ ./hi.sh "Alice"
    :  Hello Alice
~~~

We even have a default value, for the parameter so:

~~~
    :$ ./hello.sh
    :  Hello World
~~~

As you can see this new version of our script can take as input values entered by the user.

------

## As a Teacher

Now that we have seen what a student, reads.

How can we *produce* the diff output in a way that stays always consistent.
But is *NOT* a screenshot or a copy paste of the output of a single time command?

Well you can write it like this, and the output would like the one we want.
But we don't want the command to be visible for our students.
That might confuse them,
so we need to execute the command, and make *only its output* part of the tutorial.
For that we use `codebraid`.

is a tool for literate programming that allows us to write command in markdown, but by using its special `.cb-run` property
it can show the output of the command not its input.

~~~{.bash .cb-run}
  :$ git diff hi.sh@rev... hi.sh@rev...
~~~

to execute it we use:

~~~
  :$ codebraid pandoc --from markdown --to html --output ./doc/3rd_level.html
~~~

You can see that `codebraid` depends on the execution of `pandoc` good thing  that `pandoc` is the most popular tool used to transform documents from one format to another.

Now if you read the ./doc/3rd_level.html file you would find that it doesn't contain any mention of the `diff` command
It just shows how it's output. Which is precisely what we want for our student.

One could make the case that making it just a copy paste from our interaction with the `diff` command line would be enough in this situation.

But remember we are building this `testoria` to stand the passage of time.
So probably a new version of our software or a new library, in the future is going to force us to write another version of the `hi.sh` script and therefore comparing versions with the new one, will be very easy to change for our command.

### Finding this improvement in our map

|              | Reader (Student) | Author (Tech writer, Content  Engineer)              | DevOps                 |
|--------------|------------------|------------------------------------------------------|------------------------|
| Super System |                  | clitest, act, actlint and CMS - GitHub Pages         | GitHub Actions..       |
| System       | Executing hi.sh  | ./docs_source/hello_world.md                         | Testorial.yml workflow |
| Sub-system   | the script hi.sh | commands inside our tutorial not for public consumpt |                        |

## As Tester

Now the good news you.

For a tester nothing to do!

Just continue to run the workflows when you decide.

### Finding this improvement in our map

This stage doesn't modify anything on our workflow.
Just like DevOps like it, because they don't get affected with more work.
And yet reap the benefits of having a correct tutorial.


|              | Reader (Student) | Author (Tech writer, Content  Engineer)              | DevOps                 |
|--------------|------------------|------------------------------------------------------|------------------------|
| Super System |                  | clitest, act, actlint and CMS - GitHub Pages         | GitHub Actions..       |
| System       | Executing hi.sh  | ./docs_source/hello_world.md                         | Testorial.yml workflow |
| Sub-system   | the script hi.sh | commands inside our tutorial not for public consumpt |                        |

# Tutorial Conclusion :ignore:

And with that we have written a Testorial that covers a wide range of problems you might encounter when putting this ideas into practice.

# What have we learned?

+ There are 9 windows / context :: We need to consider all of them when writing executable documentation.
  But *one by one* if we think of them all at once we get confused. So we can simply decide the following paragraph.
  For whom is it? and on what of it's contexts (super-system, system or sub-system) and just focus on that level.


+ Writing executable documentation is hard, but LLMs make it easier:
  As we have seen we need to use 3 hats to write executable documentation, but fortunately we just need to be proficient in them. with the help of LLMs we can do things that before required experts.

+ There is no single tool to do executable documentation.
  On this tutorial we used:
  - clitest, to execute our tutorial.
  - codebraid to  fine invisible executable blocks.
  - pandoc to create an html version of our tutorial
  - GitHub Actions to define the CI workflow.
  - act to simulate locally, how our tutorial would run on GitHub Action servers.
  - plus our standard text editor!


 But your selection of tools is very contextual specific.
 For example if your team uses another Continuous Integration tool not github actions, then you would need to change the workflow.yml file. To orient yourself you just need to keep in mind the 9 windows.

# Is it worth it?

If you want to have always correct, and up-to-date documentation and help your QA team with *real* test cases.
It is definitively worth it, now that it has become cheaper to do it, with the help of LLMs

# Footnotes

[fn:7] codex exec "Where is stored the workflow that publishes a markdown to github pages?"

[fn:6] codex exec "How can I take a screenshot from a website from the command line ?"

[fn:5] A linter is program that reads the instructions in a program and gives you suggestions on how to improve it's style. Or points coding that could be errors.

[fn:4] https://github.com/aureliojargas/clitest

[fn:3] [[https://en.wikipedia.org/wiki/Nine_windows][Wikipedia: Nine Windows]]

[fn:2] [[https://en.wikipedia.org/wiki/Literate_programming][wikipedia: Literate Programming]]

[fn:1] MacNamara, Riona:
[[https://www.youtube.com/watch?v=EnB8GtPuauw][Documentation, Disrupted: How Two Technical Writers Changed Google Engineering Culture]]
 Write the Docs conference 2015

# 9 windows filled


*********************************************************************************************************
*                     ┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ Audience ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓    *
*                                                                                                       *
*                          Learner                   Tech Writer               DevOps                   *
*    ⎡                ╔═════════════════════════╦══════════════════════════╦════════════════════════╗   *
*    ⎢                ║                         ║                          ║                        ║   *
*    ⎢                ║                         ║                          ║                        ║   *
*    ⎢       Context  ║ Operating System        ║  CMS GitHub Pages        ║                        ║   *
*    ⎢                ║                         ║                          ║                        ║   *
*    ⎢                ║                         ║                          ║                        ║   *
*    ⎢                ║ IDE (VS Code)           ║  Act container image ---copies--> Git Hub Runner  ║   *
*    ⎢                ║                         ║      ^                   ║                        ║   *
*    ⎢                ╠═════════════════════════╬══════|═══════════════════╬════════════════════════╣   *
*    ⎢                ║                         ║      |                   ║                        ║   *
*    ⎢                ║                         ║      |                   ║                        ║   *
* Level     Artifact  ║ Tutorial.md <--cb pandoc--- Testorial.md ----clitest---> Workflow.yml       ║   *
*    ⎢                ║     |                   ║   ^          ^           ║                        ║   *
*    ⎢                ║     |                   ║   |          |           ║                        ║   *
*    ⎢                ║   types                 ║   cb include cb run      ║                        ║   *
*    ⎢                ║     |                   ║   |          |           ║                        ║   *
*    ⎢                ╠═════|═══════════════════╬═══|══════════|═══════════╬════════════════════════╣   *
*    ⎢                ║     |                   ║   |          |           ║                        ║   *
*    ⎢                ║     |                   ║   |          |           ║                        ║   *
*    ⎢                ║     v                   ║   |          |           ║                        ║   *
*    ⎢         Parts  ║ hello.sh                ║  hello.sh   diff         ║                        ║   *
*    ⎢                ║                         ║                          ║                        ║   *
*    ⎢                ║                         ║                          ║                        ║   *
*    ⎢                ║                         ║                          ║                        ║   *
*    ⎣                ╚═════════════════════════╩══════════════════════════╩════════════════════════╝   *
*                                                                                                       *
*********************************************************************************************************

# Appendix: Configuring GitHub Pages

## Install GitHub Pages

For simplicity we will use a a CMS GitHub pages.

To do that you just need to follow the instructions [https://docs.github.com/en/pages/quickstart](in the quickstart).

When you are finish you can see your webpages here: https://$USERNAME.github.io/

And it will look something like this [fn:6]:

![Default GitHub Page](./images/default_github_page.png "Default A GitHub Page")

## Modify a GitHub Page

Now let's modify the default `readme.md` document to shouw that the update mechains works.

Clone your repository to your local machine:

~~~{.bash .invisible}
    @author:$ export $USERNAME='jag-academy'
    @author: exit 0
~~~

~~~ bash
    @author:$ gh repo clone $USERNAME/$USERNAME.github.io
    @author: exit 0 # your command executed without errors
~~~

That would create your local copy of your repository.

Now you can modify the `readme.md` file.

Like this little script would simply append the current date and time to the readme file
to make sure it is modified.

~~~
   @author:$ cd $USERNAME.github.io
   @author:$ echo "modified on: $(date +'%Y%m%d %H:%M:%S')" >> README.md
~~~

Now do commit and push


~~~
  @author:$ git commit -am "Append current date and time to trigger regeneration"
  @author:$ git push
~~~

this will start the republishing of the page.

## Check the publishing pipeline

Now go to [https://github.com/jag-academy/jag-academy.github.io/actions](github.com/$USERNAME/$REPO/actions) to see your page as it is being renerated.

Observe that the workflow it's on yellow while it is running.

You can even check the detail process that is following.

When it finally turns to green means your new website is finished.

![Your workflow is in yellow while it runs and green once it passes](./images/workflows.png)

Got your link again and should see the document with the new date time.

https://$USERNAME.github.io/

# OrgDeep :IGNORE:
<script>markdeepOptions={tocStyle:'long'};</script>
<!-- Markdeep: --><style class="fallback">body{visibility:hidden;white-space:pre;font-family:monospace}</style>
<script src="https://morgan3d.github.io/markdeep/latest/markdeep.min.js" charset="utf-8"></script>
<script>window.alreadyProcessedMarkdeep||(document.body.style.visibility="visible")</script>
